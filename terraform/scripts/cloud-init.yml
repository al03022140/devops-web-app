#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - unzip
  - htop
  - git

runcmd:
  # Install Docker
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  - echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
  - apt-get update
  - apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  - systemctl start docker
  - systemctl enable docker
  - usermod -aG docker root

  # Create application directory
  - mkdir -p /opt/devops-app
  - cd /opt/devops-app

  # Create docker-compose file
  - echo "${docker_compose_content}" | base64 -d > docker-compose.yml

  # Create environment file
  - echo "${env_content}" | base64 -d > .env

  # Create data directories
  - mkdir -p data/mysql
  - mkdir -p data/prometheus
  - mkdir -p data/grafana
  - chown -R 472:472 data/grafana

  # Start services
  - docker compose pull
  - docker compose up -d

  # Setup log rotation
  - |
    cat > /etc/logrotate.d/docker-containers << EOF
    /var/lib/docker/containers/*/*.log {
      rotate 7
      daily
      compress
      size=1M
      missingok
      delaycompress
      copytruncate
    }
    EOF

  # Setup monitoring script
  - |
    cat > /opt/devops-app/health-check.sh << 'EOF'
    #!/bin/bash
    
    # Check if containers are running
    if ! docker compose ps | grep -q "Up"; then
      echo "$(date): Some containers are down, restarting..." >> /var/log/health-check.log
      docker compose up -d
    fi
    
    # Check application health
    if ! curl -f http://localhost:3000/health > /dev/null 2>&1; then
      echo "$(date): Application health check failed, restarting app container..." >> /var/log/health-check.log
      docker compose restart app
    fi
    EOF

  - chmod +x /opt/devops-app/health-check.sh

  # Setup cron job for health checks
  - echo "*/5 * * * * root /opt/devops-app/health-check.sh" >> /etc/crontab

  # Setup firewall
  - ufw allow ssh
  - ufw allow 80
  - ufw allow 443
  - ufw allow 3000
  - ufw allow 3001
  - ufw allow 9090
  - ufw --force enable

write_files:
  - path: /etc/docker/daemon.json
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "10m",
          "max-file": "3"
        }
      }
    permissions: '0644'

  - path: /opt/devops-app/backup.sh
    content: |
      #!/bin/bash
      DATE=$(date +%Y%m%d_%H%M%S)
      BACKUP_DIR="/opt/backups"
      
      mkdir -p $BACKUP_DIR
      
      # Backup database
      # Detect DB name from environment or default to devops_app
      DB_NAME=${MYSQL_DATABASE:-devops_app}
      docker compose exec -T mysql sh -lc "mysqldump -u root -p$MYSQL_ROOT_PASSWORD $DB_NAME" > $BACKUP_DIR/db_backup_$DATE.sql
      
      # Backup application data
      tar -czf $BACKUP_DIR/app_backup_$DATE.tar.gz /opt/devops-app --exclude=/opt/devops-app/data/mysql
      
      # Keep only last 7 days of backups
      find $BACKUP_DIR -name "*.sql" -mtime +7 -delete
      find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete
      
      echo "$(date): Backup completed" >> /var/log/backup.log
    permissions: '0755'

final_message: "DevOps application server setup completed successfully!"